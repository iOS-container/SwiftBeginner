/// Y_T
# Swift值类型
--------------

### Int类型

> 1.Swift中**Int**类型的长度与运行的平台有关,运行在32位系统中,**Int**等价于**Int32**,运行在64位系统中**Int**等价于**Int64**
 
> 2.Swift**Int**类型为结构体

> 3.**Int**类型的最大值**Int.max**,最小值**Int.min**,如果想**Int**类型等于**0**,可以尝试用**Int.zero**

> 4.Swift中随机数不在需要自己手动调用C 的API,可以尝试一下操作
> `
> /// 返回指定范围的 随机数 可以传入 Range<Int>  CloseRange<Int> 区间
    var random = Int.random(0…255)
  `

>  5.Swift类型运算符
> 
>        a. + - * / % 四则运算符
>        b. += -= /= *= 运算表达式 **static func 运算表达式 (inout Int, Int)**
>        c. &+ &- &* &+= &-= &*=  溢出运算符 (默认情况下，当你往一个整型常量或变量赋于一个它不能承载的大数时，Swift不会让你这么干的，它会报错。这样，在操作过大或过小的数的时候就很安全了。)
>        d. & &= | |= ^ ^= ~ 按位运算符
>        e. << <<= >> >>= &<< &<<= &>> &>>= 位运算符
>        f. == !== < > <= >= 比较运算符
>        g. ..< (Rane<Int>) ...(CloseRange<Int> or PartialRangeFrom<Int>)
> 		  h. + - 正负运算符
> 6.注意点: **Float**、**Double** 转换成Int类型注意数据溢出,可以先转成**NSNumbr**后,在转换成**Int**类型(有趣的是 如果通过**NSNumber**转换,一旦数据溢出, 转换出来的值等于**Int.min**)
> 
> 7.集成`Numeric`协议的实数类型绝对值可以调用 `self.magnitude`,也可以用`abs(:)`
> 
> 8.[类型demo](./Code/BaseTypeProtocol.swift)
         
    
### Float类型
> 1.Swift中**Float**类型的长度与运行的平台有关,运行在32位系统中,**Float**等价于**Float32**,运行在64位系统中**Float**等价于**Float64**
> 
> 2.Swift中**Float**类型为结构体
> 
> 3.**Float**类型的最大值**Float.greatestFiniteMagnitude**,最小值**Float.leastNormalMagnitude**,如果想**Float**类型等于**0**,可以尝试用**Float.zero**
> 
> 4.**Float**计算高精度可以尝试用**NSDecimalNumber**类型作为转换
> 
> 5.**Float**精度是大部分人关注的,初始化可以通过这几个构造方法
> `
> 
	init?<Source>(exactly: Source) 
  	例如:let source = 1
	let t  = Float(exactly: source)
	print(t ?? 0)
	init?(exactly: Double)
	init?(exactly: Float)
	init?(exactly: Float80)
	init?(exactly: NSNumber)
> 
> 
> 6.[精度拓展](./Code/NSDecimalNumber+YTExtension.swift)

### Bool类型
> 1.`Swift`中的**Bool**类型,并非与`Objective-C`中的**BOOL**类型一样,`非0`或者`nil`就为`假(false或者NO)`
> `
> 	
	var godotHasArrived = false
	let numbers = 1...5
	let containsTen = numbers.contains(10)
	print(containsTen)
	// Prints "false"
	let (a, b) = (100, 101)
	let aFirst = a < b
	print(aFirst)
> 
> 
> 2.`Swift`中**Bool**和`Objective-C`中的**BOOL**都是`C`语言的`bool`类型桥接的
> 
> 3.`Swift`中`Bool`运算符只有两个 `==` 和 `!=`
> 
> 4.`Swift`中取反函数`toggle()` 实现:
> 
	@inlinable
	public mutating func toggle() {
	 	self = !self
	}

### ENUM类型
> 1.`Swift`中枚举,与`Objective-C`中有区别
> 
> 		a.Objective-C中ENUM为整型(NSInteger、Int)类型,Swift中ENUM类型可以为整型(Integer,Int)、浮点型(Float)、字符串(String)、布尔类型(Boolean)
> 		b.Swift中ENUM类型可以定义方法
> 		c.
