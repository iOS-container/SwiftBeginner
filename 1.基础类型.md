/// Y_T
# Swift值类型
-------

### Int类型

> 1.Swift中**Int**类型的长度与运行的平台有关,运行在32位系统中,**Int**等价于**Int32**,运行在64位系统中**Int**等价于**Int64**
 
> 2.Swift**Int**类型为结构体

> 3.**Int**类型的最大值**Int.max**,最小值**Int.min**,如果想**Int**类型等于**0**,可以尝试用**Int.zero**

> 4.Swift中随机数不在需要自己手动调用C 的API,可以尝试一下操作
> `
> /// 返回指定范围的 随机数 可以传入 Range<Int>  CloseRange<Int> 区间
    var random = Int.random(0…255)
  `

>  5.Swift类型运算符
> 
>        a. + - * / % 四则运算符
>        b. += -= /= *= 运算表达式 **static func 运算表达式 (inout Int, Int)**
>        c. &+ &- &* &+= &-= &*=  溢出运算符 (默认情况下，当你往一个整型常量或变量赋于一个它不能承载的大数时，Swift不会让你这么干的，它会报错。这样，在操作过大或过小的数的时候就很安全了。)
>        d. & &= | |= ^ ^= ~ 按位运算符
>        e. << <<= >> >>= &<< &<<= &>> &>>= 位运算符
>        f. == !== < > <= >= 比较运算符
>        g. ..< (Rane<Int>) ...(CloseRange<Int> or PartialRangeFrom<Int>)
> 		  h. + - 正负运算符
> 6.注意点: **Float**、**Double** 转换成Int类型注意数据溢出,可以先转成**NSNumbr**后,在转换成**Int**类型(有趣的是 如果通过**NSNumber**转换,一旦数据溢出, 转换出来的值等于**Int.min**)
> 
> 7.[./code/基础类型.swift](#MarkDown锚点)
         
    
### Float类型
> 1.Swift中**Float**类型的长度与运行的平台有关,运行在32位系统中,**Float**等价于**Float32**,运行在64位系统中**Float**等价于**Float64**
> 
> 2.Swift中**Float**类型为结构体
> 
> 3.**Float**类型的最大值**Float.greatestFiniteMagnitude**,最小值**Float.leastNormalMagnitude**,如果想**Float**类型等于**0**,可以尝试用**Float.zero**
> 
> 4.**Float**计算高精度可以尝试用**NSDecimalNumber**类型作为转换
> 
> 5.**Float**精度是大部分人关注的,初始化可以通过这几个构造方法
> `
> 	 init?<Source>(exactly: Source) <br>
> 	 例如:let source = 1
		  let t  = Float(exactly: source)
		  print(t ?? 0)
	init?(exactly: Double)
	init?(exactly: Float)
	init?(exactly: Float80)
	init?(exactly: NSNumber)
> `
